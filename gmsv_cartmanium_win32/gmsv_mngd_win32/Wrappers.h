// This file has been generated by Cartman300's WrapperGenerator

static void gluaL_register(lua_State *L, System::String ^STR_libname, const luaL_Reg *l) {
	CSTR(libname);
	luaL_register(L, libname, l);
	DSTR(libname);
}

static int gluaL_getmetafield(lua_State *L, int obj, System::String ^STR_e) {
	CSTR(e);
	auto RET = luaL_getmetafield(L, obj, e);
	DSTR(e);
	return RET;
}

static int gluaL_callmeta(lua_State *L, int obj, System::String ^STR_e) {
	CSTR(e);
	auto RET = luaL_callmeta(L, obj, e);
	DSTR(e);
	return RET;
}

static int gluaL_typerror(lua_State *L, int narg, System::String ^STR_tname) {
	CSTR(tname);
	auto RET = luaL_typerror(L, narg, tname);
	DSTR(tname);
	return RET;
}

static int gluaL_argerror(lua_State *L, int numarg, System::String ^STR_extramsg) {
	CSTR(extramsg);
	auto RET = luaL_argerror(L, numarg, extramsg);
	DSTR(extramsg);
	return RET;
}

static System::String ^gluaL_checklstring(lua_State *L, int numArg, size_t *l) {
	return RSTR(luaL_checklstring(L, numArg, l));
}

static System::String ^gluaL_optlstring(lua_State *L, int numArg, System::String ^STR_def, size_t *l) {
	CSTR(def);
	const char* RET = luaL_optlstring(L, numArg, def, l);
	DSTR(def);
	return RSTR(RET);
}

static lua_Number gluaL_checknumber(lua_State *L, int numArg) {
	return luaL_checknumber(L, numArg);
}

static lua_Number gluaL_optnumber(lua_State *L, int nArg, lua_Number def) {
	return luaL_optnumber(L, nArg, def);
}

static lua_Integer gluaL_checkinteger(lua_State *L, int numArg) {
	return luaL_checkinteger(L, numArg);
}

static lua_Integer gluaL_optinteger(lua_State *L, int nArg, lua_Integer def) {
	return luaL_optinteger(L, nArg, def);
}

static void gluaL_checkstack(lua_State *L, int sz, System::String ^STR_msg) {
	CSTR(msg);
	luaL_checkstack(L, sz, msg);
	DSTR(msg);
}

static void gluaL_checktype(lua_State *L, int narg, int t) {
	return luaL_checktype(L, narg, t);
}

static void gluaL_checkany(lua_State *L, int narg) {
	return luaL_checkany(L, narg);
}

static int gluaL_newmetatable(lua_State *L, System::String ^STR_tname) {
	CSTR(tname);
	auto RET = luaL_newmetatable(L, tname);
	DSTR(tname);
	return RET;
}

static void *gluaL_checkudata(lua_State *L, int ud, System::String ^STR_tname) {
	CSTR(tname);
	void* RET = luaL_checkudata(L, ud, tname);
	DSTR(tname);
	return RET;
}

static void gluaL_where(lua_State *L, int lvl) {
	return luaL_where(L, lvl);
}

static int gluaL_error(lua_State *L, System::String ^STR_str) {
	CSTR(str);
	int R = luaL_error(L, "%s", str);
	return R;
}

// FUNCTION gluaL_checkoption EXPUNGED

static int gluaL_ref(lua_State *L, int t) {
	return luaL_ref(L, t);
}

static void gluaL_unref(lua_State *L, int t, int ref) {
	return luaL_unref(L, t, ref);
}

static int gluaL_loadfile(lua_State *L, System::String ^STR_filename) {
	CSTR(filename);
	auto RET = luaL_loadfile(L, filename);
	DSTR(filename);
	return RET;
}

static int gluaL_loadbuffer(lua_State *L, System::String ^STR_buff, size_t sz, System::String ^STR_name) {
	CSTR(buff); CSTR(name);
	auto RET = luaL_loadbuffer(L, buff, sz, name);
	DSTR(buff); DSTR(name);
	return RET;
}

static int gluaL_loadstring(lua_State *L, System::String ^STR_s) {
	CSTR(s);
	auto RET = luaL_loadstring(L, s);
	DSTR(s);
	return RET;
}

static lua_State *gluaL_newstate() {
	return luaL_newstate();
}

static System::String ^gluaL_gsub(lua_State *L, System::String ^STR_s, System::String ^STR_p, System::String ^STR_r) {
	CSTR(s); CSTR(p); CSTR(r);
	const char* RET = luaL_gsub(L, s, p, r);
	DSTR(s); DSTR(p); DSTR(r);
	return RSTR(RET);
}

static System::String ^gluaL_findtable(lua_State *L, int idx, System::String ^STR_fname, int szhint) {
	CSTR(fname);
	const char* RET =  luaL_findtable(L, idx, fname, szhint);
	DSTR(fname);
	return RSTR(RET);
}

static void gluaL_buffinit(lua_State *L, luaL_Buffer *B) {
	return luaL_buffinit(L, B);
}

static char *gluaL_prepbuffer(luaL_Buffer *B) {
	return luaL_prepbuffer(B);
}

static void gluaL_addlstring(luaL_Buffer *B, System::String ^STR_s, size_t l) {
	CSTR(s);
	luaL_addlstring(B, s, l);
	DSTR(s);
}

static void gluaL_addstring(luaL_Buffer *B, System::String ^STR_s) {
	CSTR(s);
	luaL_addstring(B, s);
	DSTR(s);
}

static void gluaL_addvalue(luaL_Buffer *B) {
	return luaL_addvalue(B);
}

static void gluaL_pushresult(luaL_Buffer *B) {
	return luaL_pushresult(B);
}

static lua_State *glua_newstate(lua_Alloc f, void *ud) {
	return lua_newstate(f, ud);
}

static void glua_close(lua_State *L) {
	return lua_close(L);
}

static lua_State *glua_newthread(lua_State *L) {
	return lua_newthread(L);
}

static lua_CFunction glua_atpanic(lua_State *L, lua_CFunction panicf) {
	return lua_atpanic(L, panicf);
}

static int glua_gettop(lua_State *L) {
	return lua_gettop(L);
}

static void glua_settop(lua_State *L, int idx) {
	return lua_settop(L, idx);
}

static void glua_pushvalue(lua_State *L, int idx) {
	return lua_pushvalue(L, idx);
}

static void glua_remove(lua_State *L, int idx) {
	return lua_remove(L, idx);
}

static void glua_insert(lua_State *L, int idx) {
	return lua_insert(L, idx);
}

static void glua_replace(lua_State *L, int idx) {
	return lua_replace(L, idx);
}

static int glua_checkstack(lua_State *L, int sz) {
	return lua_checkstack(L, sz);
}

static void glua_xmove(lua_State *from, lua_State *to, int n) {
	return lua_xmove(from, to, n);
}

static int glua_isnumber(lua_State *L, int idx) {
	return lua_isnumber(L, idx);
}

static int glua_isstring(lua_State *L, int idx) {
	return lua_isstring(L, idx);
}

static int glua_iscfunction(lua_State *L, int idx) {
	return lua_iscfunction(L, idx);
}

static int glua_isuserdata(lua_State *L, int idx) {
	return lua_isuserdata(L, idx);
}

static int glua_type(lua_State *L, int idx) {
	return lua_type(L, idx);
}

static System::String ^glua_typename(lua_State *L, int tp) {
	return RSTR(lua_typename(L, tp));
}

static int glua_equal(lua_State *L, int idx1, int idx2) {
	return lua_equal(L, idx1, idx2);
}

static int glua_rawequal(lua_State *L, int idx1, int idx2) {
	return lua_rawequal(L, idx1, idx2);
}

static int glua_lessthan(lua_State *L, int idx1, int idx2) {
	return lua_lessthan(L, idx1, idx2);
}

static lua_Number glua_tonumber(lua_State *L, int idx) {
	return lua_tonumber(L, idx);
}

static System::String ^glua_tostring(lua_State* L, int idx) {
	return RSTR(lua_tostring(L, idx));
}

static lua_Integer glua_tointeger(lua_State *L, int idx) {
	return lua_tointeger(L, idx);
}

static int glua_toboolean(lua_State *L, int idx) {
	return lua_toboolean(L, idx);
}

static System::String ^glua_tolstring(lua_State *L, int idx, size_t *len) {
	return RSTR(lua_tolstring(L, idx, len));
}

static size_t glua_objlen(lua_State *L, int idx) {
	return lua_objlen(L, idx);
}

static lua_CFunction glua_tocfunction(lua_State *L, int idx) {
	return lua_tocfunction(L, idx);
}

static void *glua_touserdata(lua_State *L, int idx) {
	return lua_touserdata(L, idx);
}

static lua_State *glua_tothread(lua_State *L, int idx) {
	return lua_tothread(L, idx);
}

static const void *glua_topointer(lua_State *L, int idx) {
	return lua_topointer(L, idx);
}

static void glua_pushnil(lua_State *L) {
	return lua_pushnil(L);
}

static void glua_pushnumber(lua_State *L, lua_Number n) {
	return lua_pushnumber(L, n);
}

static void glua_pushinteger(lua_State *L, lua_Integer n) {
	return lua_pushinteger(L, n);
}

static void glua_pushlstring(lua_State *L, System::String ^STR_s, size_t l) {
	CSTR(s);
	lua_pushlstring(L, s, l);
	DSTR(s);
}

static void glua_pushstring(lua_State *L, System::String ^STR_s) {
	CSTR(s);
	lua_pushstring(L, s);
	DSTR(s);
}

static System::String ^glua_pushvfstring(lua_State *L, System::String ^STR_fmt, va_list argp) {
	CSTR(fmt);
	auto RET = lua_pushvfstring(L, fmt, argp);
	DSTR(fmt);
	return RSTR(RET);
}

static void glua_pushfstring(lua_State *L, System::String ^STR_fmt, params array<System::Object^> ^Args) {
	System::String ^STR_format = System::String::Format(STR_fmt, Args);
	CSTR(format);
	lua_pushstring(L, format);
	DSTR(format);
}

static void glua_pushcclosure(lua_State *L, lua_CFunction fn, int n) {
	return lua_pushcclosure(L, fn, n);
}

static void glua_pushboolean(lua_State *L, int b) {
	return lua_pushboolean(L, b);
}

static void glua_pushlightuserdata(lua_State *L, void *p) {
	return lua_pushlightuserdata(L, p);
}

static int glua_pushthread(lua_State *L) {
	return lua_pushthread(L);
}

static void glua_gettable(lua_State *L, int idx) {
	return lua_gettable(L, idx);
}

static void glua_getfield(lua_State *L, int idx, System::String ^STR_k) {
	CSTR(k);
	lua_getfield(L, idx, k);
	DSTR(k);
}

static void glua_rawget(lua_State *L, int idx) {
	return lua_rawget(L, idx);
}

static void glua_rawgeti(lua_State *L, int idx, int n) {
	return lua_rawgeti(L, idx, n);
}

static void glua_createtable(lua_State *L, int narr, int nrec) {
	return lua_createtable(L, narr, nrec);
}

static void *glua_newuserdata(lua_State *L, size_t sz) {
	return lua_newuserdata(L, sz);
}

static int glua_getmetatable(lua_State *L, int objindex) {
	return lua_getmetatable(L, objindex);
}

static void glua_getfenv(lua_State *L, int idx) {
	return lua_getfenv(L, idx);
}

static void glua_settable(lua_State *L, int idx) {
	return lua_settable(L, idx);
}

static void glua_setfield(lua_State *L, int idx, System::String ^STR_k) {
	CSTR(k);
	lua_setfield(L, idx, k);
	DSTR(k);
}

static void glua_rawset(lua_State *L, int idx) {
	return lua_rawset(L, idx);
}

static void glua_rawseti(lua_State *L, int idx, int n) {
	return lua_rawseti(L, idx, n);
}

static int glua_setmetatable(lua_State *L, int objindex) {
	return lua_setmetatable(L, objindex);
}

static int glua_setfenv(lua_State *L, int idx) {
	return lua_setfenv(L, idx);
}

static void glua_call(lua_State *L, int nargs, int nresults) {
	return lua_call(L, nargs, nresults);
}

static int glua_pcall(lua_State *L, int nargs, int nresults, int errfunc) {
	return lua_pcall(L, nargs, nresults, errfunc);
}

static int glua_cpcall(lua_State *L, lua_CFunction func, void *ud) {
	return lua_cpcall(L, func, ud);
}

static int glua_load(lua_State *L, lua_Reader reader, void *dt, System::String ^STR_chunkname) {
	CSTR(chunkname);
	auto RET = lua_load(L, reader, dt, chunkname);
	DSTR(chunkname);
	return RET;
}

static int glua_dump(lua_State *L, lua_Writer writer, void *data) {
	return lua_dump(L, writer, data);
}

static int glua_yield(lua_State *L, int nresults) {
	return lua_yield(L, nresults);
}

/* // FUNCTION glua_resume EXPUNGED
static int glua_resume(lua_State *L, int narg) {
	return lua_resume(L, narg);
}
*/

static int glua_status(lua_State *L) {
	return lua_status(L);
}

static int glua_gc(lua_State *L, int what, int data) {
	return lua_gc(L, what, data);
}

static int glua_error(lua_State *L) {
	return lua_error(L);
}

static int glua_next(lua_State *L, int idx) {
	return lua_next(L, idx);
}

static void glua_concat(lua_State *L, int n) {
	return lua_concat(L, n);
}

static lua_Alloc glua_getallocf(lua_State *L, void **ud) {
	return lua_getallocf(L, ud);
}

static void glua_setallocf(lua_State *L, lua_Alloc f, void *ud) {
	return lua_setallocf(L, f, ud);
}

/* // FUNCTION glua_setlevel EXPUNGED
static void glua_setlevel(lua_State *from, lua_State *to) {
	return lua_setlevel(from, to);
}
*/

static int glua_getstack(lua_State *L, int level, lua_Debug *ar) {
	return lua_getstack(L, level, ar);
}

static int glua_getinfo(lua_State *L, System::String ^STR_what, lua_Debug *ar) {
	CSTR(what);
	auto RET = lua_getinfo(L, what, ar);
	DSTR(what);
	return RET;
}

static System::String ^glua_getlocal(lua_State *L, const lua_Debug *ar, int n) {
	return RSTR(lua_getlocal(L, ar, n));
}

static System::String ^glua_setlocal(lua_State *L, const lua_Debug *ar, int n) {
	return RSTR(lua_setlocal(L, ar, n));
}

static System::String ^glua_getupvalue(lua_State *L, int funcindex, int n) {
	return RSTR(lua_getupvalue(L, funcindex, n));
}

static System::String ^glua_setupvalue(lua_State *L, int funcindex, int n) {
	return RSTR(lua_setupvalue(L, funcindex, n));
}

static int glua_sethook(lua_State *L, lua_Hook func, int mask, int count) {
	return lua_sethook(L, func, mask, count);
}

static lua_Hook glua_gethook(lua_State *L) {
	return lua_gethook(L);
}

static int glua_gethookmask(lua_State *L) {
	return lua_gethookmask(L);
}

static int glua_gethookcount(lua_State *L) {
	return lua_gethookcount(L);
}